# ğŸ¦€ Rust Programming Mastery
_______________________________________________________________________________

### Why I chose to make Rust my most proficient programming language

My first programming language was **ğŸ“˜ Delphi (Object Pascal)**...

And since then I've tried out quite a number programming languages:

- ğŸ”· C++
- ğŸ”¹ C
- ğŸ¹ Go
- ğŸª„ TypeScript
- ğŸ Python

**C++** was a very close second, 
but ultimately I chose Rust as my primary language because 
it uniquely satisfies eight critical criteria 
that align with my long-term development goals:

_______________________________________________________________________________

## 1. **ğŸ® Rust allows me to build a wide variety of things**

- The focus of Rust on memory safe low-level systems programming,
but it is not a niche DSL (Domain specific language).

- It can be used to solve business challenges across multiple domains like,
back-end services, game development, robotics, devops, 
cli tool development, operating systems, full-stack web development, 
mobile development and many more.

- Ultimately I want a language that is powerful and versatile enough 
to grow with my ambition and any future endevours I decide to persue. 
_______________________________________________________________________________

## 2. **ğŸ¨ Rust is not strongly tied to front-end / web development work**

I have nothing against front-end work or web development. 

I just don't like JSX which unfortunely plagues the most of front-end / 
web development work. This is why I prefer a tech stack that keeps things
simple: 

- **ğŸ¦• Deno** (which is written in Rust)
- TypeScript
- Svelte / SvelteKit,
- Tailwind CSS / CSS
- and GSAP
- and deploying on either **Deno Deploy** or **AWS**

However, front-end / web development is not what I want to devote my life
towards as I prefer more terminal-centric fields.

_______________________________________________________________________________

## 3. **ğŸ’¡ Strong, Static Type System**

- I want a language that is statically typed 
and strongly typed (not just type hints, or type checks while I code) 
but actual types that are enforced at compile time.

- I would rather be alerted of potential issues and stopped from proceeding,
then to ship sloppy work, that could have a dire impact on client trust. 

- I like Rust's focus on memory safety and graceful approach to defensive
programming. 

Many Rust functions and methods return a Result enum, or an Option enum.

This alerts you about common potential errors, and forces you to think
critically about how to handle the errors so that you spend less time 
in the debugger. 

_______________________________________________________________________________

## 4. **ğŸ¤– Explicit Memory Control**

- I want a language that gives me direct control over stack-allocation,
and heap-allocation. This low-level control is essential for understanding 
performance characteristics and writing efficient code.

- I don't want to memorize DSA problems while implementing them 
in a language where DSA is not the norm / rarely needed due to the nature of
the work being done.

_______________________________________________________________________________

## 5. **ğŸ‘‰ First-Class Pointers and References**

- Rust has built-in syntax for references (`&`, `&mut`) 
and raw pointers (`*const`, `*mut`), 
plus straightforward ways to inspect memory addresses. 

- Memory management is a language-level concern, not an afterthought.

- I like being able to prove that my code is doing what I intend it to do.

_______________________________________________________________________________

## 6. **ğŸ’œ Rust is used by technologies that I use daily**

Many of the tools that I rely on daily are written in Rust:

- **wezterm** - terminal emulator
- **deno** - JavaScript/TypeScript runtime
- **uv** - Python package manager
- **mise** - dev tool version manager
- **bat** - cat alternative
- **yazi** - file manager
- **paru** - AUR helper
- **lsd** - ls alternative

Choosing Rust means understanding the technology that powers my workflow,
and also opens up the potential of giving back to tools that have changed
how I use my computer. 

_______________________________________________________________________________

## 7. **ğŸ§ Rust is being adopted by global projects that are meant to last**

Rust has proven it's here to stay:
- Integrated into the **Linux kernel**
- Major C++ projects being **rewritten in Rust**
- Adopted by Microsoft, Google, Amazon, Meta, and countless others

- Despite vocal critics, the trajectory is clear: 
Rust is a long-term investment, not a fad.

- I want to be on the ship of the future, 
rather than be dragged onboard as a reluctant late adopter.

_______________________________________________________________________________

## 8. **ğŸ“š World-Class Tooling and Centralized Ecosystem** 

- I want a language with a development environment that is easy to setup, 
and reproduce, without relying on external tools.

The Rust toolchain (`rustup` + `cargo`) is unmatched in the industry:
- **One standard way** to create, build, test, and run projects
- **No makefiles, no tool proliferation, no fragmentation**
- **Integrated package management, documentation, and testing**
- **Built-in html documentation creator**

- Anyone who disagree is either intellectually bankrupt or beingÂ dishonest. 

- I like that when it comes to running, building andÂ creating Rust packages,Â 
there is a standard way of doing things 
that does not involve learning multiple tools, makefiles etc like in the
C++ ecosystem.

- Ironically I chose Rust because I'm done playing safe,
and choosing sub-par options simply because they are used by more companies.

_______________________________________________________________________________
